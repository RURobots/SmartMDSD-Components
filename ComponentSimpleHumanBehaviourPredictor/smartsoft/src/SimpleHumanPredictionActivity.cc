//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include <climits>
#include "CartesianPosition.h"
#include "Transformation.h"
using namespace RUR_RobotMaths;
#include "SimpleHumanPredictionActivity.hh"
#include "ComponentSimpleHumanBehaviourPredictor.hh"

#include <iostream>


SimpleHumanPredictionActivity::SimpleHumanPredictionActivity(SmartACE::SmartComponent *comp) 
:	SimpleHumanPredictionActivityCore(comp)
{
	std::cout << "constructor SimpleHumanPredictionActivity\n";
}
SimpleHumanPredictionActivity::~SimpleHumanPredictionActivity() 
{
	std::cout << "destructor SimpleHumanPredictionActivity\n";
}
void SimpleHumanPredictionActivity::on_HumanSkeletonsPushServiceIn(const DomainHumanTracking::CommHumanPositionsAndVelocities &input)
{
	COMP->simpleHumanBehaviourPredictorMutex.acquire();
	{
		//Save the input skeletons
		COMP->humanPositionsAndVelocities = input;

		// Perform the predictions and save the results
		CalculatePredictions(input, COMP->humanPositionPredictions);

		// Output the newest prediction
		COMP->humanPredictionsPushServiceOut->put(COMP->humanPositionPredictions);
	}
	COMP->simpleHumanBehaviourPredictorMutex.release();
}
int SimpleHumanPredictionActivity::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int SimpleHumanPredictionActivity::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

	double decaySpeed = COMP->getGlobalState().getConfiguration().getDecaySpeed();

	COMP->simpleHumanBehaviourPredictorMutex.acquire();
	{
		for (int bodyIndex = 0; bodyIndex < MAX_BODIES; bodyIndex++)
		{
			for (int axisIndex = 0; axisIndex < 3; axisIndex++)
			{
				COMP->maxPosition[bodyIndex][axisIndex] -= decaySpeed / 30.0;
				COMP->minPosition[bodyIndex][axisIndex] += decaySpeed / 30.0;
			}
		}
	}
	COMP->simpleHumanBehaviourPredictorMutex.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int SimpleHumanPredictionActivity::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
void SimpleHumanPredictionActivity::CalculatePredictions(const DomainHumanTracking::CommHumanPositionsAndVelocities &input, DomainHumanTracking::CommHumanPositionPredictions &output)
{
	const bool displayDebugInfo = COMP->getGlobalState().getSettings().getDebug_info();		// Controls if debug information is printed

	// Calculate the transformation from sensor frame to world frame
	CartesianPosition sensorPosition;
	sensorPosition[0] = COMP->getGlobalState().getSensorPosition().getX();
	sensorPosition[1] = COMP->getGlobalState().getSensorPosition().getY();
	sensorPosition[2] = COMP->getGlobalState().getSensorPosition().getZ();
	sensorPosition[3] = COMP->getGlobalState().getSensorPosition().getRoll();
	sensorPosition[4] = COMP->getGlobalState().getSensorPosition().getElevation();
	sensorPosition[5] = COMP->getGlobalState().getSensorPosition().getAzimuth();
	Transformation sensorToWorld;
	sensorToWorld.FromCartesianPosition(sensorPosition);

	if (displayDebugInfo)
	{
		std::cout << "sensorToWorld:" << std::endl;
		sensorToWorld.Print();
	}

	if (displayDebugInfo && (input.getBodyDataSize() == 0))
	{
		std::cout << "Null data sent (no bodies)." << std::endl;
	}

	// Make the PredictedData array answer variable the required size
	output.resizePredictedData(input.getBodyDataSize());

	// Process all of the joints in all of the bodies
	for (int bodyIndex = 0; (bodyIndex < input.getBodyDataSize()) && (bodyIndex < MAX_BODIES); bodyIndex++)
	{
		for (int jointIndex = 0; jointIndex < input.getBodyDataElemAtPos(bodyIndex).getJointDataSize(); jointIndex++)
		{
			if (
				input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getIsJointTracked() == DomainHumanTracking::JointTrackingStateType::TRACKED
			) {
				CartesianPosition jointStartingPosition;
				jointStartingPosition = CartesianPosition::Zeros();
				jointStartingPosition[0] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getX();
				jointStartingPosition[1] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getY();
				jointStartingPosition[2] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getZ();
				jointStartingPosition = sensorToWorld.Transform(jointStartingPosition);
				jointStartingPosition =	COMP->worldToOutputFrame.InverseTransform(jointStartingPosition);

				CartesianPosition jointEndingPosition;
				jointEndingPosition = CartesianPosition::Zeros();
				jointEndingPosition[0] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getX() + (COMP->duration * input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointVelocity3d().getX());
				jointEndingPosition[1] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getY() + (COMP->duration * input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointVelocity3d().getY());
				jointEndingPosition[2] = input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointPosition3d().getZ() + (COMP->duration * input.getBodyDataElemAtPos(bodyIndex).getJointDataElemAtPos(jointIndex).getJointVelocity3d().getZ());
				jointEndingPosition = sensorToWorld.Transform(jointEndingPosition);
				jointEndingPosition = COMP->worldToOutputFrame.InverseTransform(jointEndingPosition);

				// Check for max and min axis limits
				for (int axisIndex = 0; axisIndex < 3; axisIndex++)
				{
					// Check start positions
					if (jointStartingPosition[axisIndex] > COMP->maxPosition[bodyIndex][axisIndex])
					{
						COMP->maxPosition[bodyIndex][axisIndex] = jointStartingPosition[axisIndex];
					}
					if (jointStartingPosition[axisIndex] < COMP->minPosition[bodyIndex][axisIndex])
					{
						COMP->minPosition[bodyIndex][axisIndex] = jointStartingPosition[axisIndex];
					}

					// Check final positions
					if (jointEndingPosition[axisIndex] > COMP->maxPosition[bodyIndex][axisIndex])
					{
						COMP->maxPosition[bodyIndex][axisIndex] = jointEndingPosition[axisIndex];
					}
					if (jointEndingPosition[axisIndex] < COMP->minPosition[bodyIndex][axisIndex])
					{
						COMP->minPosition[bodyIndex][axisIndex] = jointEndingPosition[axisIndex];
					}

				} // Axis index loop
			} // If joint is tracked
		} // Joint index loop

		// Construct the output data
		DomainHumanTracking::CommPredictedData predictedData;
		predictedData.setValid(true);
		predictedData.setXMaxLimit(COMP->maxPosition[bodyIndex][0]);
		predictedData.setXMinLimit(COMP->minPosition[bodyIndex][0]);
		predictedData.setYMaxLimit(COMP->maxPosition[bodyIndex][1]);
		predictedData.setYMinLimit(COMP->minPosition[bodyIndex][1]);
		predictedData.setZMaxLimit(COMP->maxPosition[bodyIndex][2]);
		predictedData.setZMinLimit(COMP->minPosition[bodyIndex][2]);

		// Save the predictions for this body
		output.setPredictedDataElemAtPos(bodyIndex, predictedData);

		if (displayDebugInfo)
		{
			std::cout << "Body " << bodyIndex << " X: " << predictedData.getXMinLimit() << " -> " << predictedData.getXMaxLimit() << std::endl;
			std::cout << "Body " << bodyIndex << " Y: " << predictedData.getYMinLimit() << " -> " << predictedData.getYMaxLimit() << std::endl;
			std::cout << "Body " << bodyIndex << " Z: " << predictedData.getZMinLimit() << " -> " << predictedData.getZMaxLimit() << std::endl;
		}
	} // Body index loop
}
